__TOC__

Now, let's move on building a networking application. We provide you with starter code for a hub controller. After getting yourself familiar with it, you'll modify the provided hub to act as an L2 learning switch.  In this application, the switch will examine each packet and learn the source-port mapping.  Thereafter, the source MAC address will be associated with the port.  If the destination of the packet is already associated with some port, the packet will be sent to the given port, else it will be flooded on all ports of the switch.

Later, you'll turn this into a flow-based switch, where seeing a packet with a known source and dest causes a flow entry to get pushed down.

For this tutorial you will use the Beacon controller.

== Beacon (Java) ==
Beacon is a Java-based OpenFlow controller platform.  For more details and tutorials see the [[Beacon Homepage|http://www.beaconcontroller.net]]. 

==== Start Eclipse ====
Start Eclipse by double clicking the Eclipse shortcut on the desktop.

=== Running the Tutorial Controller ===

Make sure the reference controller used before is not running, run the following in a terminal:
 $ sudo killall controller

You should also restart Mininet to make sure that everything is "clean". From your Mininet console:
 mininet> exit
 $ sudo mn --topo single,3 --mac --switch ovsk --controller remote

Make sure you do not add extra spaces around the comma.

Now it's time to start Beacon in Debug mode.

Within Eclipse do the following:

* Run -> Debug Configurations
* Look for the OSGi Framework on the left, expand its children and select 'beacon Tutorial LearningSwitch', then click Debug.

This command will start Beacon, including the 'tutorial' bundle, listening to incoming connection from switches on the standard OpenFlow port (6633).

Wait until the application indicates that the OpenFlow switch has connected.  When the switch connects, your Eclipse console should print something like this: 

01:07:31.095 [pool-2-thread-2] INFO  n.b.core.internal.Controller - Switch connected from java.nio.channels.SocketChannel[connected local=/192.168.206.2:6633 remote=/192.168.206.4:54994]

=== Verify Hub Behavior with tcpdump ===

Now we verify that hosts can ping each other, and that all hosts see the exact same traffic - the behavior of a hub.  To do this, we'll create xterms for each host, and view the traffic in each.  In the Mininet console, start up three xterms:
 mininet> xterm h1 h2 h3

<font color=red>''' TODO: These xterm windows are not named properly, the .bashrc command prompt is overwriting the title '''</font>

Arrange each xterm so that they're all on the screen at once.  This may require reducing the height of to fit a cramped laptop screen.

In the xterms for h2 and h3, run tcpdump, a utility to print the packets seen by a host:
 # tcpdump -XX -n -i h2-eth0

and respectively:
 # tcpdump -XX -n -i h3-eth0

In the xterm for h1, send a ping:
 # ping -c1 10.0.0.2

The ping packets are now going up to the controller, which then floods them out all interfaces except the sending one.   You should see identical ARP and ICMP packets corresponding to the ping in both xterms running tcpdump.

Now, see what happens when a non-existent host doesn't reply.  From h2 xterm:
 # ping -c1 10.0.0.5

You should see three unanswered ARP requests in the tcpdump xterms.  If your code is off later, three unanswered ARP requests is a signal that you might be accidentally dropping packets.

You can close the xterms now.

=== Benchmark Hub Controller w/iperf ===
Here, you'll benchmark the provided hub code, part of the Tutorial bundle.

First, verify reachability.  Mininet should be running, along with your Beacon tutorial controller.  In the Mininet console, run:
 mininet> pingall

This is just a sanity check for connectivity.  Now, in the Mininet console, run:
 mininet> iperf

Now, compare your number with the reference controller you saw before. How does that compare?

=== Open Tutorial Code and Begin ===

Go to Eclipse and stop Beacon (you should see a square, red button in the console window, or the top left section of Eclipse if you are in the Debug perspective).

'''NOTE : You can run only one controller at the same time (otherwise you'll get a port conflict). Make sure that you stop any running instance of Beacon before you start another one. With Eclipse this might be tricky. To check the running programs open the Debug perspective (Window->Open Perspective->Debug). On the top-left corner you can see the running programs, click on it then hit the red square to terminate the redundant ones...'''

{| style="color:black; background-color:#ffffff;" cellpadding="10" cellspacing="0" border="1"
| [[images/200px-Eclipse_console_stop.png|width=200px]]
| [[images/200px-Eclipse_debug_stop.png|width=200px]]
|}

The file you'll modify is '''net.beaconcontroller.tutorial/src/main/java/net/beaconcontroller/tutorial/LearningSwitchTutorial.java'''.  Find this file in the left pane of Eclipse and double-click it to open it in the editor window.

Take a quick look through the file, the key things to notice:
* The receive method is where packets initially arrive from switches, by default this method calls forwardAsHub.  Once you have implemented the code in forwardAsLearningSwitch you should change receive by commenting out the call to forwardAsHub, and uncommenting the call to forwardAsLearningSwitch.
* The forwardAsHub method behaves as a broadcast hub, and has code that gives you an example of how to send an OFPacketOut message.
* The forwardAsLearningSwitch method is where you will be writing all of your code (with the exception of the receive method mentioned earlier).  It should take you around 30 lines of code in this method to implement a learning switch.

Use Wireshark to inspect the packets sent and received by your controller to help debug your code.

API documentation is available for both Beacon's classes and the general Java classes, look for the shortcuts on your desktop to launch a browser to view these.

Each time you change and save the LearningSwitchTutorial file, make sure to stop and start your running instance, then use pings to verify hub or Ethernet learning switch behavior.  Hosts that are not the destination should display no tcpdump traffic after the initial broadcast ARP request.

There is a significant number of comments in the LearningSwitchTutorial file to help you create the proper functionality, and tips provided in the subsequent sections of this tutorial ('''read these!''').  At a high level there are two phases of work for you to do:

==== Phase 1 ====
----
===== Overview =====
* Build an OFMatch object based on the incoming OFPacketIn
* Learn that the source MAC address is at the incoming port and store it in the Map
* Retrieve the port the destination MAC address is at, if it is known
* If the destination port is known, send an OFPacketOut directly and only to that port, else forward using the flooding method in the forwardAsHub method

At the end of this phase you should be able to send pings back and forth, and in Wireshark you should see an initial OFPacketOut in both directions with its action set to flood, subsequent OFPacketOut messages should have their action set to send to a single port.

===== Tips =====
* To log a message to the console
<dl><dd><pre>
log.debug("Your message here")
</pre></dd></dl>

* The ''OFMatch'' class can be used to retrieve packet header data contained in the ''OFPacketIn'' class.  The following command will return a new ''OFMatch'' object containing data from the ''OFPacketIn'' pi object.
<dl><dd><pre>
 match.loadFromPacket(pi.getPacketData(), pi.getInPort()); 
</pre></dd></dl>

* The following command shows how to add an element to a Map
<dl><dd><pre>
 macTable.put(mac_address_key, port)
</pre></dd></dl>

* The macTable Map object is keyed by the ''Long'' data type, but MAC addresses in the ''OFMatch'' class are byte[].  The following command will take a byte[] from the match object and return a Long:
<dl><dd><pre>
 Ethernet.toLong(match.getDataLayerSource())
</pre></dd></dl>

* You can also convert a byte[] to a String for easy logging:
<dl><dd><pre>
log.debug("MAC Address:" + HexString.toHexString(match.getDataLayerSource()))
</pre></dd></dl>

* To check for an element in your HashMap:
<dl><dd><pre>
 if (macTable.containsKey(mac_address_key)) {
   do..something..here
 }
</pre></dd></dl>

* To get an element from the HashMap:
<dl><dd><pre>
 learned_port = macTable.get(mac_address_key)
</pre></dd></dl>


==== Phase 2 ====
----
===== Overview =====
* If the destination port is known, instead of sending an OFPacketOut, send an OFFlowMod so that subsequent pings are matched on the switch.

At the end of phase 2, when pinging and viewing the controller traffic in Wireshark you should see an initial OFPacketOut that floods for the request/response, then an OFFlodMod being sent for both request/response, then no further traffic for the same ping.

===== Tips =====
* To install a flow in the network you will create an ''OFFlowMod'' object:
<dl><dd><pre>
 OFFlowMod fm = new OFFlowMod();
</pre></dd></dl>

* Before you can send the ''OFFlowMod'' to the switch you will need to initialize the following fields of the object:
** buffer id - Retrieve this from the ''OFPacketIn''
** match - You created this in Phase 1
** command - Add, OFFlowMod.OFPFC_ADD
** idle timeout - 5 seconds
** actions - See the next Tip

* You ''OFFlowMod'' when matched should output to the port learned for this destination, use the snippet below to create the action and set it on the ''OFFlowMod'' instance:
<dl><dd><pre>
 OFActionOutput action = new OFActionOutput(outPort);
 fm.setActions(Collections.singletonList((OFAction)action));
</pre></dd></dl>

* To send a message to an OpenFlow switch do the following:
<dl><dd><pre>
 sw.getOutputStream().write(po);
</pre></dd></dl>

== Testing Your Controller ==

Once you have completed both Phases 1 and 2 you can start a ping and using dpctl to verify the flows exist and check their counters.  Another indicator is that pings after the first complete much faster, because they are not passing through the controller.  You can also verify this behavior by running iperf in Mininet and checking that only initial packet-in messages are sent.  The reported iperf bandwidth should be much higher as well, and should match the number you got when using the reference learning switch controller earlier.

If you want to continue, you have three options:
* run your code over real networking gear (if you are on a live tutorial)
* add layer-3 forwarding capabilities to your switch
* add firewall capabilities to your switch

Proceed to the section you prefer.

