__TOC__

Now, let's move on building a networking application. We provide you with starter code for a hub controller. After getting yourself familiar with it, you'll modify the provided hub to act as an L2 learning switch.  In this application, the switch will examine each packet and learn the source-port mapping.  Thereafter, the source MAC address will be associated with the port.  If the destination of the packet is already associated with some port, the packet will be sent to the given port, else it will be flooded on all ports of the switch.

Later, you'll turn this into a flow-based switch, where seeing a packet with a known source and dest causes a flow entry to get pushed down.

For this tutorial you will use the Beacon controller.

== Beacon (Java) ==
Beacon is a Java-based OpenFlow controller platform.  For more details and tutorials see the [[Beacon Homepage|http://www.beaconcontroller.net]]. 

==== Start Eclipse ====
Start Eclipse by double clicking the Eclipse shortcut on the desktop.

=== Running the Tutorial Controller ===

Make sure the reference controller used before is not running, run the following in a terminal:
 $ sudo killall controller

You should also restart Mininet to make sure that everything is "clean". From your Mininet console:
 mininet> exit
 $ sudo mn --topo single,3 --mac --switch ovsk --controller remote

Make sure you do not add extra spaces around the comma.

Now it's time to start Beacon in Debug mode.

Within Eclipse do the following:

* Run -> Debug Configurations
* Look for the OSGi Framework on the left, expand its children and select 'beacon Tutorial LearningSwitch', then click Debug.

This command will start Beacon, including the 'tutorial' bundle, listening to incoming connection from switches on the standard OpenFlow port (6633).

Wait until the application indicates that the OpenFlow switch has connected.  When the switch connects, your Eclipse console should print something like this: 

01:07:31.095 [pool-2-thread-2] INFO  n.b.core.internal.Controller - Switch connected from java.nio.channels.SocketChannel[connected local=/192.168.206.2:6633 remote=/192.168.206.4:54994]

=== Verify Hub Behavior with tcpdump ===

Now we verify that hosts can ping each other, and that all hosts see the exact same traffic - the behavior of a hub.  To do this, we'll create xterms for each host, and view the traffic in each.  In the Mininet console, start up three xterms:
 mininet> xterm h1 h2 h3

<font color=red>''' TODO: These xterm windows are not named properly, the .bashrc command prompt is overwriting the title '''</font>

Arrange each xterm so that they're all on the screen at once.  This may require reducing the height of to fit a cramped laptop screen.

In the xterms for h2 and h3, run tcpdump, a utility to print the packets seen by a host:
 # tcpdump -XX -n -i h2-eth0

and respectively:
 # tcpdump -XX -n -i h3-eth0

In the xterm for h1, send a ping:
 # ping -c1 10.0.0.2

The ping packets are now going up to the controller, which then floods them out all interfaces except the sending one.   You should see identical ARP and ICMP packets corresponding to the ping in both xterms running tcpdump.

Now, see what happens when a non-existent host doesn't reply.  From h2 xterm:
 # ping -c1 10.0.0.5

You should see three unanswered ARP requests in the tcpdump xterms.  If your code is off later, three unanswered ARP requests is a signal that you might be accidentally dropping packets.

You can close the xterms now.

=== Benchmark Hub Controller w/iperf ===
Here, you'll benchmark the provided hub code, part of the Tutorial bundle.

First, verify reachability.  Mininet should be running, along with your Beacon tutorial controller.  In the Mininet console, run:
 mininet> pingall

This is just a sanity check for connectivity.  Now, in the Mininet console, run:
 mininet> iperf

Now, compare your number with the reference controller you saw before. How does that compare?

=== Open Tutorial Code and Begin ===

Go to Eclipse and stop Beacon (you should see a square, red button in the console window, or the top left section of Eclipse if you are in the Debug perspective).

'''NOTE : You can run only one controller at the same time (otherwise you'll get a port conflict). Make sure that you stop any running instance of Beacon before you start another one. With Eclipse this might be tricky. To check the running programs open the Debug perspective (Window->Open Perspective->Debug). On the top-left corner you can see the running programs, click on it then hit the red square to terminate the redundant ones...'''

{| style="color:black; background-color:#ffffff;" cellpadding="10" cellspacing="0" border="1"
| [[images/200px-Eclipse_console_stop.png|width=200px]]
| [[images/200px-Eclipse_debug_stop.png|width=200px]]
|}

The file you'll modify is '''net.beaconcontroller.tutorial/src/main/java/net/beaconcontroller/tutorial/LearningSwitchTutorial.java'''.  Find this file in the left pane of Eclipse and double-click it to open it in the editor window.

Take a quick look through the file, the key things to notice:
* The receive method is where packets initially arrive from switches, by default this method calls forwardAsHub.  Once you have implemented the code in forwardAsLearningSwitch you should change receive by commenting out the call to forwardAsHub, and uncommenting the call to forwardAsLearningSwitch.
* The forwardAsHub method behaves as a broadcast hub, and has code that gives you an example of how to send an OFPacketOut message.
* The forwardAsLearningSwitch method is where you will be writing all of your code (with the exception of the receive method mentioned earlier).  It should take you around 30 lines of code in this method to implement a learning switch.

Wireshark will be very useful to you in getting your code working.  Try starting Beacon and doing some pings with Mininet while capturing with Wireshark.  You should see OFPacketIn and OFPacketOut messages, and if you explore the OFPacketOut messages you should see their action is to flood.

Each time you change and save the LearningSwitchTutorial file, make sure to stop and start your running instance, then use pings to verify hub or Ethernet learning switch behavior.  Hosts that are not the destination should display no tcpdump traffic after the initial broadcast ARP request.

There is a significant number of comments in the LearningSwitchTutorial file to help you create the proper functionality, and tips provided in the subsequent sections of this tutorial ('''read these!''').  At a high level there are two phases of work for you to do.

==== Phase 1 ====
* Build an OFMatch object based on the incoming OFPacketIn
* Learn that the source MAC address is at the incoming port and store it in the Map
* Retrieve the port the destination MAC address is at, if it is known
* If the destination port is known, send an OFPacketOut directly and only to that port, else forward using the flooding method in the forwardAsHub method

At the end of this phase you should be able to send pings back and forth, and in Wireshark you should see an initial OFPacketOut in both directions with its action set to flood, subsequent OFPacketOut messages should have their action set to send to a single port.

==== Phase 2 ====
* If the destination port is known, instead of sending an OFPacketOut, send an OFFlowMod so that subsequent pings are matched on the switch.

At the end of phase 2, when pinging and viewing the controller traffic in Wireshark you should see an initial OFPacketOut that floods for the request/response, then an OFFlodMod being sent for both request/response, then no further traffic for the same ping.

=== Learning Java and Beacon ===

Here are a few Java tips you might find useful down the road.

To add an element to a HashMap:
 macTable.put(mac_address_key, port)

To convert a MAC address in a byte[] to a Long:
 Ethernet.toLong(match.getDataLayerSource()/match.getDataLayerDestination())

To check for an element in your HashMap:
 if (macTable.containsKey(mac_address_key))
    log.debug("mac_address_key is in hashmap")

To get an element from the HashMap:
```
 learned_port = macTable.get(mac_address_key)
``` 
To print a debug message in Beacon:
 log.debug("Learned new MAC!")

You can change the logging level using info or error instead of debug.

The subsections below give details about a few Beacon Classes that should prove useful in the exercise.

=== Useful Beacon Classes ===

In your beacon-tutorial-1.0.2 directory, there is an apidocs folder which contains Javadoc documentation for all essential classes in this assignment.
Open your browser and point to [your beacon-tutorial-1.0.2 directory]/apidocs/index.html and look for the classes mentioned below, which should help while implementing your code.

To send a message to an OpenFlow switch, look at IOFSwitch class. The starter forward_as_hub function sends packets out using:
 sw.getOutputStream().write(po);

Look at OFMatch and OFPacketIn to get header information from an OpenFlow packet-in. You should find the following command particularly useful:
 match.loadFromPacket(pi.getPacketData(), pi.getInPort()); 

Down the road, you may want to print a mac address, or use it as a key to a HashMap. OFMatch will give you the address as a byte array. Use the functions/classes below in case needed:
 HexString.toHexString(byte[] bytes) // Convert a string of bytes to a ':' separated hex string
 Long mac_address_key = Ethernet.toLong(byte array); // Creates a Long key from a byte array.

Finally, at some  point you will have to install a flow in the network. Use OFFlowMod and OFActionOutput to do that. Here is a way to initialize a flow-mod message for a specific switch:
 OFFlowMod fm = new OFFlowMod();

Use the appropriate setters to construct the flow-mod you need. Assuming you know the outgoing port for this flow, this is a snippet on how to include this in your flow-mod message:
 OFActionOutput action = new OFActionOutput(outPort);
 fm.setActions(Collections.singletonList((OFAction)action));

Now, skip ahead to Testing Your Controller below.

== Testing Your Controller ==

To test your controller-based Ethernet switch, first verify that when all packets arrive at the controller, only broadcast packets (like ARPs) and packets with unknown destination locations (like the first packet sent for a flow) go out all non-input ports.  You can do this with tcpdump running on an xterm for each host.

Once the switch no longer has hub behavior, work to push down a flow when the source and destination ports are known.  You can use dpctl to verify the flow counters, and if subsequent pings complete much faster, you'll know that they're not passing through the controller.  You can also verify this behavior by running iperf in Mininet and checking that no OpenFlow packet-in messages are getting sent.  The reported iperf bandwidth should be much higher as well, and should match the number you got when using the reference learning switch controller earlier.

== Support Multiple Switches ==

Your controller so far has only had to support a single switch, with a single MAC table.  In this section, you'll extend it to support multiple switches.

Start mininet with a different topology.  In the Mininet console:
 mininet> exit
 $ sudo mn --topo linear --switch ovsk --controller remote


Your created topology looks like this:


[[images/Linear2.png]]


This will create a 2-switch topology where each switch has a single connected host.

Now, modify your switch so that it stores a MAC-to-port table for each DPID.  This strategy only works on spanning tree networks, and the delay for setting up new paths between far-away hosts is proportional to the number of switches between them.  Other modules could act smarter. For example, one can maintain an all-pairs shortest path data structure and immediately push down all flow entries needed to previously-seen sources and destinations. This is out-of-scope for this assignment.

After the mods, to verify that your controller works, in the Mininet console, run:
 mininet> pingall

Congratulations on getting this far.  If you are doing this as part of the CS244 assignment, you are done! 


If you want to continue, you have three options:
* run your code over real networking gear (if you are on a live tutorial)
* add layer-3 forwarding capabilities to your switch
* add firewall capabilities to your switch

Proceed to the section you prefer.

